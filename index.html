<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>KB & Transcript SPA (Implicit Grant)</title>
  <!-- Load Spark components and styling -->
  <script type="module" src="https://app.usw2.pure.cloud/spark-components/build-assets/4.88.0-373/genesys-webcomponents/genesys-webcomponents.esm.js"></script>
  <link href="https://app.usw2.pure.cloud/spark-components/build-assets/4.88.0-373/genesys-webcomponents/genesys-webcomponents.css" rel="stylesheet" />
  <style>
    section { padding: 8px; margin: auto; max-width: 800px; }
    pre { background: #f4f4f4; padding: 16px; border-radius: 4px; max-height: 300px; overflow: auto; white-space: pre-wrap; }
  </style>


</head>
<body>
  <!-- Auth section -->
  <section id="authSection" hidden>
    <gux-page-header>
      <h1 slot="heading" align="center">Authenticate</h1>
    </gux-page-header>
    <gux-form-field-text-like>
      <label slot="label">Client ID</label>
      <input type="text" slot="input" id="inputClientId" placeholder="Enter your Client ID" />
    </gux-form-field-text-like>
    <gux-form-field-text-like>
      <label slot="label">Genesys Cloud Region</label>
      <input type="text" slot="input" id="inputRegion" placeholder="e.g. usw2" />
    </gux-form-field-text-like>
    <div style="margin-top:16px; text-align:center;">
      <gux-button accent="primary" id="btnAuth">Authenticate</gux-button>
    </div>
 
  </section>

  <!-- Main app section (hidden until auth) -->
  <section id="appSection" hidden>
    <gux-page-header>
      <h1 slot="heading" align="center">Suggestions Manager</h1>
    </gux-page-header>

  <!-- NEW: Users multi-select -->
   <h3 > User Selection</h3>
    <div style="margin: 4px 0;">
      <div id="userHeader" class="empty"></div>
      <gux-dropdown-multi placeholder="Select one or more users" id="multi-users" filter-type="starts-with">
        <gux-listbox-multi aria-label="Users" id="Users-Id">
        </gux-listbox-multi>
      </gux-dropdown-multi>
    </div>
   
 <h3 > Queue Selection</h3>

      <gux-dropdown-multi placeholder="Select one or more Queues" id="queue-users" filter-type="starts-with">
        <gux-listbox-multi aria-label="Queues" id="Queues-Id">
        </gux-listbox-multi>
      </gux-dropdown-multi>
    <!-- Form fields -->
       <h3 style="margin: 1px;"> Interval Selection</h3>
    <gux-form-field-text-like style="margin: 1px;">
      <input type="text" slot="input" id="inputInterval" placeholder="2025-01-01T00:00:00/2025-01-02T00:00:00" />
    
    </gux-form-field-text-like>

     

          <h3 style="margin: 1px;"> Batch Size Selection</h3>

    <gux-form-field-text-like style="margin: 1px;">
      <input type="number" slot="input" id="inputBatchSize" placeholder="10" />
    </gux-form-field-text-like>

    <!-- Action buttons -->
    <div style="display: flex; gap: 8px; margin-top: 16px;">
      <gux-button accent="primary" id="btnTranscripts">Run Transcripts & Download CSV</gux-button>
      <gux-button accent="secondary" id="btnLogout">Logout</gux-button>
    </div>
       

    <!-- Log output -->
    <pre id="log"></pre>
  </section>

  <script>
    // helper to log both console and on-page
    const logEl = document.getElementById('log');
    function log(msg) {
      console.log(msg);
      logEl.textContent += msg + '\n';
    }


    
    window.addEventListener('load', () => {
      // 1) parse URL params & sync to sessionStorage
      const url = new URL(window.location.href);
      let gc_region          = url.searchParams.get('gc_region');
      let gc_clientId        = url.searchParams.get('gc_clientId');
      let gc_redirectUrl     = url.searchParams.get('gc_redirectUrl');
      let gc_conversationId  = url.searchParams.get('gc_conversationId');

      if (gc_region) {
        sessionStorage.setItem('gc_region', gc_region);
      } else {
        gc_region = sessionStorage.getItem('gc_region');
      }
      if (gc_clientId) {
        sessionStorage.setItem('gc_clientId', gc_clientId);
      } else {
        gc_clientId = sessionStorage.getItem('gc_clientId');
      }
      if (gc_redirectUrl) {
        sessionStorage.setItem('gc_redirectUrl', gc_redirectUrl);
      } else {
        gc_redirectUrl = sessionStorage.getItem('gc_redirectUrl');
      }
      if (gc_conversationId) {
        sessionStorage.setItem('gc_conversationId', gc_conversationId);
      } else {
        gc_conversationId = sessionStorage.getItem('gc_conversationId');
      }

      //log(`Params → region:${gc_region}, clientId:${gc_clientId}, redirectUrl:${gc_redirectUrl}`);

      // 2) check for token in hash & localStorage
      const hash = window.location.hash.substring(1);
      const params = new URLSearchParams(hash);
      const tokenFromHash = params.get('access_token');
      if (tokenFromHash) {
        //log('Received token in URL hash, saving to localStorage');
        localStorage.setItem('accessToken', tokenFromHash);
        history.replaceState(null, '', window.location.pathname);
      }
      const token = localStorage.getItem('accessToken');

      // 3) decide whether to auto‐redirect, show auth form, or show app
      if (!gc_region || !gc_clientId || !gc_redirectUrl) {
    // no region/clientId/redirectUri → back to auth
    document.getElementById('authSection').hidden = false;
    document.getElementById('appSection').hidden = true;
    return;
  }

  // 4) now that we have config, handle token or OAuth redirect
  if (token) {
    //log('Token found – showing app');
    document.getElementById('authSection').hidden = true;
    document.getElementById('appSection').hidden = false;
   
    // after login, populate the dropdown
    async function populateUsers() {
      const token  = localStorage.getItem('accessToken');
      const region = sessionStorage.getItem('gc_region');
      try {
        // show a temporary placeholder
        userListbox=document.getElementById("Users-Id");
    
    //    userListbox.innerHTML = '<gux-option-multi disabled>Loading users…</gux-option-multi>';
        const users = await loadAllUsers(region, token);
        //userListbox.innerHTML = '';  // clear
        users.forEach(u => {
          const opt = document.createElement('gux-option-multi');
          opt.setAttribute('value',u.id);
          opt.innerText = u.name;
          userListbox.appendChild(opt);

        });
                console.log('Appended', users.length, 'options to listbox:', userListbox);

      }
      catch (e) {
        console.error(e);
        userListbox.innerHTML = '<gux-option-multi disabled>Error loading users</gux-option-multi>';
      }
      userDropdown.requestContentUpdate?.();


      //updateUserHeader();
    }
    populateUsers();
  
   async function populateQueues() {
      const token  = localStorage.getItem('accessToken');
      const region = sessionStorage.getItem('gc_region');
      try {
        // show a temporary placeholder
        queueListbox=document.getElementById("Queues-Id");
    
        const queues = await loadAllqueues(region, token);
        queues.forEach(u => {
          const opt = document.createElement('gux-option-multi');
          opt.setAttribute('value',u.id);
          opt.innerText = u.name;
          queueListbox.appendChild(opt);

        });
                console.log('Appended', queues.length, 'options to listbox:', queueListbox);

      }
      catch (e) {
        console.error(e);
        queueListbox.innerHTML = '<gux-option-multi disabled>Error loading queues</gux-option-multi>';
      }
      queueDropdown.requestContentUpdate?.();


      //updateUserHeader();
    }
    populateQueues();
  }
  else {
    //log('No token yet, auto‐redirecting to OAuth');
    const authUrl = `https://login.${gc_region}.pure.cloud/oauth/authorize` +
                    `?response_type=token&client_id=${gc_clientId}` +
                    `&redirect_uri=${encodeURIComponent(gc_redirectUrl)}`;
    window.location.href = authUrl;
  }
    });
       const userDropdown = document.querySelector('gux-dropdown-multi');
       let userListbox  = userDropdown.querySelector('gux-listbox-multi');
        const queueDropdown = document.querySelector('gux-dropdown-multi');
       let queueListbox  = userDropdown.querySelector('gux-listbox-multi');
       const userHeader   = document.getElementById('userHeader');
              const queueHeader   = document.getElementById('queueHeader');


 function updateUserHeader() {
      const selected = Array.from(userListbox.querySelectorAll('gux-option-multi[selected]'));
      console.log('Listbox element is:', userListbox);
    console.log('Children count:', userListbox.children.length);
    console.log(userListbox.innerHTML);

      userHeader.textContent = '';
      userHeader.classList.toggle('empty', selected.length === 0);
      selected.forEach(opt => {
        const chip = document.createElement('span');
        chip.className = 'chip';
        chip.textContent = opt.textContent.trim();
        userHeader.appendChild(chip);
      });
    }
    
    userDropdown.addEventListener('guxchanged', updateUserHeader);
    userDropdown.addEventListener('guxcollapsed', updateUserHeader);
 
    function updateQueueHeader() {
      const selected = Array.from(queueListbox.querySelectorAll('gux-option-multi[selected]'));
      console.log('Listbox element is:', queueListbox);
    console.log('Children count:', queueListbox.children.length);
    console.log(queueListbox.innerHTML);

      queueHeader.textContent = '';
      queueHeader.classList.toggle('empty', selected.length === 0);
      selected.forEach(opt => {
        const chip = document.createElement('span');
        chip.className = 'chip';
        chip.textContent = opt.textContent.trim();
        queueHeader.appendChild(chip);
      });
    }
    // fetch ALL users via pagination
    async function loadAllUsers(region, token) {
      let users = [];
      let next = '/api/v2/users?pageSize=100';
      while (next) {
        const resp = await fetch(`https://api.${region}.pure.cloud${next}`, {
          headers: { 'Authorization': `Bearer ${token}` }
        });
        if (!resp.ok) throw new Error(`Users API returned ${resp.status}`);
        const body = await resp.json();
        users = users.concat(body.entities || []);
        next = body.nextUri;
      }
      return users;
    }
    
    async function loadAllqueues(region, token) {
      let queues = [];
      let next = '/api/v2/routing/queues?pageSize=100';
      while (next) {
        const resp = await fetch(`https://api.${region}.pure.cloud${next}`, {
          headers: { 'Authorization': `Bearer ${token}` }
        });
        if (!resp.ok) throw new Error(`Queues API returned ${resp.status}`);
        const body = await resp.json();
        queues = queues.concat(body.entities || []);
        next = body.nextUri;
      }
      return queues;
    }
    async function loadAllConversations(region, token, bodyPayload) {
  let allConvs = [];
  let nextBody = { ...bodyPayload, paging: { pageSize: 100, pageNumber: 1 } };
  let keepGoing = true;

  while (keepGoing) {
    const resp = await fetch(
      `https://api.${region}.pure.cloud/api/v2/analytics/conversations/details/query`,
      {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(nextBody)
      }
    );
    if (!resp.ok) throw new Error(`Conversations API returned ${resp.status}`);
    const body = await resp.json();
    allConvs = allConvs.concat(body.conversations || []);

    if (body.nextUri) {
      // parse the next pageNumber from nextUri
      const url = new URL(`https://api.${region}.pure.cloud${body.nextUri}`);
      nextBody.paging.pageNumber = parseInt(url.searchParams.get('pageNumber'), 10);
    } else {
      keepGoing = false;
    }
  }

  return allConvs;
}
    // manual auth button
    document.getElementById('btnAuth').addEventListener('click', () => {
      const clientId = document.getElementById('inputClientId').value.trim();
      const region   = document.getElementById('inputRegion').value.trim();
      if (!clientId || !region) return alert('Both Client ID and Region are required.');
      const redirectUri = window.location.origin + window.location.pathname;
      sessionStorage.setItem('gc_clientId', clientId);
      sessionStorage.setItem('gc_region', region);
      sessionStorage.setItem('gc_redirectUrl', redirectUri);
      //log(`Redirecting to OAuth: region=${region}, clientId=${clientId}`);
      const authUrl = `https://login.${region}.pure.cloud/oauth/authorize` +
                      `?response_type=token&client_id=${clientId}` +
                      `&redirect_uri=${encodeURIComponent(redirectUri)}`;
      window.location.href = authUrl;
    });

    // logout
   document.getElementById('btnLogout').addEventListener('click', () => {
    log('Logging out…');
    // Remove OAuth token
    localStorage.removeItem('accessToken');
    // Remove any stored Genesys Cloud params
    sessionStorage.removeItem('gc_region');
    sessionStorage.removeItem('gc_clientId');
    sessionStorage.removeItem('gc_redirectUrl');
    sessionStorage.removeItem('gc_conversationId');
    // Refresh to return to auth form
    window.location.reload();
  });

  async function showAgents() {
    console.log(document.getElementById('Users-Id').value);
    console.log(document.getElementById('multi-users').value);
  }

  
    // main export logic
    async function mainTranscripts() {
      const token    = localStorage.getItem('accessToken');
      const region   = sessionStorage.getItem('gc_region');  
     const rawAgents = document.getElementById('multi-users').value;    // e.g. "id1,id2,id3"
  const rawQueues = document.getElementById('queue-users').value;    // e.g. "q1,q2"

  // split into real arrays
  const agentIds = rawAgents ? rawAgents.split(',') : [];
  const queueIds = rawQueues ? rawQueues.split(',') : [];
      const interval = document.getElementById('inputInterval').value;
      const batchSize = parseInt(document.getElementById('inputBatchSize').value, 10) || Infinity;
      const [start, end] = interval.split('/');

log('Fetching all conversations (with pagination)…');
const conversations = await loadAllConversations(region, token, {
  interval: `${start}/${end}`,
  order: 'desc',
  orderBy: 'conversationStart',
  segmentFilters: [
    { type: 'or', predicates: agentIds.map(id => ({ type: 'dimension', dimension: 'userId', value: id })) },
    { type: 'or', predicates: queueIds.map(id => ({ type: 'dimension', dimension: 'queueId', value: id })) }
  ]
});
log(`Conversations fetched: ${conversations.length}`);

      let batchNumber = 0;
      for (let i = 0; i < conversations.length; i += batchSize) {
        batchNumber++;
        const batch = conversations.slice(i, i + batchSize);
        log(`Processing batch ${batchNumber} (${batch.length} convs)...`);

        // fetch suggestions in parallel
        const sugData = await Promise.all(batch.map(conv =>
          fetch(`https://api.${region}.pure.cloud/api/v2/conversations/${conv.conversationId}/suggestions`, {
            headers: { 'Authorization': `Bearer ${token}` }
          })
            .then(r => r.json())
            .then(j => ({ id: conv.conversationId, entities: j.entities || [] }))
        ));

        const mergedBatch = [];
        await Promise.all(batch.map(async conv => {
          const sugEntry = sugData.find(s=>s.id===conv.conversationId);
          const sugList = sugEntry.entities
            .map(e=>({
              timestampMs: new Date(e.dateCreated).getTime(),
              documentId: e.knowledgeSearch?.document?.id || e.knowledgeArticle?.document?.id||'',
              confidence: e.knowledgeSearch?.confidence||e.knowledgeArticle?.confidence||'',
              title: e.knowledgeSearch?.title||e.knowledgeArticle?.title||'',
              type:       e.type,          // e.g. "KnowledgeSearch" or "KnowledgeArticle"
              triggerType: e.triggerType  
            }))
            .sort((a,b)=>a.timestampMs-b.timestampMs);

          const customer = conv.participants.find(p=>p.purpose==='customer');
          const sessions = customer?.sessions||[];

          await Promise.all(sessions.map(async ses => {
            if (!ses.recording) {
              log(`Skip session ${ses.sessionId}: recording disabled`);
              return;
            }
try {
  const urlReq = await fetch(
    `https://api.${region}.pure.cloud/api/v2/speechandtextanalytics/conversations/${conv.conversationId}/communications/${ses.sessionId}/transcripturl`,
    { headers: { 'Authorization': `Bearer ${token}` } }
  );

  // check for 404
  if (urlReq.status === 404) {
    const errJson = await urlReq.json();
    log(`Transcript not found: ${errJson.message}`);   // <-- uses the "message" property
    return; // skip this session
  }
  // any other non-OK status?
  if (!urlReq.ok) {
    throw new Error(`Unexpected error (${urlReq.status}): ${urlReq.statusText}`);
  }

  // now safe to parse
  const { url } = await urlReq.json();

  // fetch the actual transcript and likewise guard it
  const transcriptRes = await fetch(url);
  if (transcriptRes.status === 404) {
    const errJson = await transcriptRes.json();
    log(`Transcript content not found: ${errJson.message}`);
    return;
  }
  if (!transcriptRes.ok) {
    throw new Error(`Error loading transcript (${transcriptRes.status}): ${transcriptRes.statusText}`);
  }
  const transcript = await transcriptRes.json();

  // collect only external phrases
  const phrases = [];
  transcript.transcripts.forEach(t => {
    t.phrases
      .filter(p => p.participantPurpose === 'external')
      .forEach(p => {
        phrases.push({
          endMs: +p.startTimeMs + (p.duration?.milliseconds || 0),
          text: p.text
        });
      });
  });
  phrases.sort((a, b) => a.endMs - b.endMs);

  for (let phr of phrases) {
    for (let s of sugList) {
      const diff = s.timestampMs - phr.endMs;
      if (diff < 2000) continue;
      if (diff > 6000) break;
      mergedBatch.push({
        phrase: phr.text,
        documentId: s.documentId,
        title: s.title,
        confidence: s.confidence,
        suggestionDelayMs: diff,
        conversationId: conv.conversationId,
        type: s.type,
        triggerType: s.triggerType,
      });
      break;
    }
  }
} catch (e) {
  log(`Skip session ${ses.sessionId}: ${e.message}`);
}
          }));
        }));

        log(`Batch ${batchNumber} done, rows: ${mergedBatch.length}`);
        downloadCSV(mergedBatch, `merged_timeline_batch_${batchNumber}.csv`);
      }
    }

    function downloadCSV(rows, fname) {
      if (!rows.length) { log('No rows to export for this batch'); return; }
      const hdrs = Object.keys(rows[0]);
      const lines = rows.map(r => hdrs.map(h => `"${(r[h]||'').toString().replace(/"/g,'""')}"`).join(','));
      const csv = [hdrs.join(','), ...lines].join('\n');
      const blob = new Blob([csv],{type:'text/csv'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = fname;
      document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
    }

    document.getElementById('btnTranscripts').addEventListener('click', async () => {
      logEl.textContent = '';
      log('Starting export in batches…');
      await mainTranscripts();
    });
  </script>
</body>
</html>
