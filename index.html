<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>KB & Transcript SPA (Implicit Grant)</title>
  <!-- Load Spark components and styling -->
  <script type="module" src="https://app.usw2.pure.cloud/spark-components/build-assets/4.88.0-373/genesys-webcomponents/genesys-webcomponents.esm.js"></script>
  <link href="https://app.usw2.pure.cloud/spark-components/build-assets/4.88.0-373/genesys-webcomponents/genesys-webcomponents.css" rel="stylesheet" />
  <style>
    section { padding: 16px; margin: auto; max-width: 600px; }
    pre { background: #f4f4f4; padding: 16px; border-radius: 4px; max-height: 300px; overflow: auto; white-space: pre-wrap; }
  </style>
</head>
<body>
  <!-- Auth section -->
  <section id="authSection">
    <gux-page-header>
      <h1 slot="heading" align="center">Suggestions Manager: Authentication</h1>
    </gux-page-header>

    <gux-form-field-text-like>
      <label slot="label">Client ID</label>
      <input type="text" slot="input" id="inputClientId" placeholder="Enter your Client ID" />
    </gux-form-field-text-like>
    <br />
  <gux-form-field-text-like>
      <label slot="label">GC Region</label>
      <input type="text" slot="input" id="inputRegion" placeholder="Enter your region eg 'usw2'" />
    </gux-form-field-text-like>
    <div style="margin-top:16px; text-align:center;">
      <gux-button accent="primary" id="btnAuth">Authenticate</gux-button>
    </div>
  </section>

  <!-- Main app section (hidden until auth) -->
  <section id="appSection" hidden>
    <gux-page-header>
      <h1 slot="heading" align="center">Suggestions Manager</h1>
    </gux-page-header>

    <!-- Form fields -->
    <gux-form-field-text-like>
      <label slot="label">Agent IDs (JSON array)</label>
      <input type="text" slot="input" id="inputAgentIds" placeholder='["id1","id2"]' />
    </gux-form-field-text-like>
    <gux-form-field-text-like>
      <label slot="label">Interval (start/end ISO)</label>
      <input type="text" slot="input" id="inputInterval" placeholder="2025-01-01T00:00:00/2025-01-02T00:00:00" />
    </gux-form-field-text-like>
    <gux-form-field-text-like>
      <label slot="label">Queue IDs (JSON array)</label>
      <input type="text" slot="input" id="inputQueueIds" placeholder='["queue1","queue2"]' />
    </gux-form-field-text-like>
    <gux-form-field-text-like>
      <label slot="label">Batch Size</label>
      <input type="number" slot="input" id="inputBatchSize" placeholder="10" />
    </gux-form-field-text-like>

    <!-- Action buttons -->
    <div style="display: flex; gap: 8px; margin-top: 16px;">
      <gux-button accent="primary" id="btnTranscripts">Run Transcripts & Download CSV</gux-button>
      <gux-button accent="secondary" id="btnLogout">Logout</gux-button>
    </div>

    <!-- Log output -->
    <pre id="log"></pre>
  </section>

  <script>
    // Utility to log messages
    const logEl = document.getElementById('log');
    function log(msg) { logEl.textContent += msg + '\n'; }

    // On load, check for token in localStorage or URL hash
    window.addEventListener('load', () => {
      const hash = window.location.hash.substring(1);
      const params = new URLSearchParams(hash);
      const tokenFromHash = params.get('access_token');

      if (tokenFromHash) {
        // Save and clean up URL
        localStorage.setItem('accessToken', tokenFromHash);
        history.replaceState(null, '', window.location.pathname);
      }

      const token = localStorage.getItem('accessToken');
      if (token) {
        // Already authenticated
        document.getElementById('authSection').hidden = true;
        document.getElementById('appSection').hidden = false;
        registerSparkComponents();
      }
    });

    // Auth button handler
    document.getElementById('btnAuth').addEventListener('click', () => {
      const clientId = document.getElementById('inputClientId').value.trim();
      const region   = document.getElementById('inputRegion').value.trim();
      if (!clientId || !region) return alert('Please enter both Client ID and Region');

      const redirectUri = window.location.origin + window.location.pathname;
      const authUrl = `https://login.${region}.pure.cloud/oauth/authorize` +
                      `?response_type=token&client_id=${clientId}` +
                      `&redirect_uri=${encodeURIComponent(redirectUri)}`;
      window.location.href = authUrl;
    });

    // Logout
    document.getElementById('btnLogout').addEventListener('click', () => {
      localStorage.removeItem('accessToken');
      window.location.reload();
    });

    // Main export logic, fully async with parallel fetches
    async function mainTranscripts() {
      const token     = localStorage.getItem('accessToken');
      const region    = document.getElementById('inputRegion').value.trim();
      const agentIds  = JSON.parse(document.getElementById('inputAgentIds').value);
      const queueIds  = JSON.parse(document.getElementById('inputQueueIds').value);
      const interval  = document.getElementById('inputInterval').value;
      const batchSize = parseInt(document.getElementById('inputBatchSize').value, 10) || Infinity;
      const [start, end] = interval.split('/');

      log('Fetching conversations...');
      const convResp = await fetch(
        `https://api.${region}.pure.cloud/api/v2/analytics/conversations/details/query`, {
          method: 'POST',
          headers: { 'Authorization': `Bearer ${token}`, 'Content-Type': 'application/json' },
          body: JSON.stringify({
            interval: `${start}/${end}`, order: 'desc', orderBy: 'conversationStart', paging: { pageSize: 100 },
            segmentFilters: [
              { type: 'or', predicates: agentIds.map(id => ({ type: 'dimension', dimension: 'userId', value: id })) },
              { type: 'or', predicates: queueIds.map(id => ({ type: 'dimension', dimension: 'queueId', value: id })) }
            ]
          })
        }
      );
      const { conversations = [] } = await convResp.json();
      log(`Conversations fetched: ${conversations.length}`);

      let batchNumber = 0;
      for (let i = 0; i < conversations.length; i += batchSize) {
        batchNumber++;
        const batch = conversations.slice(i, i + batchSize);
        log(`Processing batch ${batchNumber} (${batch.length} convs)...`);

        // Fetch suggestions for all convs in parallel
        const sugData = await Promise.all(batch.map(conv =>
          fetch(`https://api.${region}.pure.cloud/api/v2/conversations/${conv.conversationId}/suggestions`,
            { headers: { 'Authorization': `Bearer ${token}` } })
            .then(r => r.json())
            .then(j => ({ id: conv.conversationId, entities: j.entities || [] }))
        ));

        const mergedBatch = [];
        // Process each conv in parallel
        await Promise.all(batch.map(async conv => {
          const { conversationId: cid } = conv;
          const entities = sugData.find(s => s.id === cid).entities;
          const sugList = entities.map(e => ({
            timestampMs: new Date(e.dateCreated).getTime(),
            documentId:  e.knowledgeSearch?.document?.id || e.knowledgeArticle?.document?.id || '',
            confidence:  e.knowledgeSearch?.confidence   || e.knowledgeArticle?.confidence   || '',
            title:       e.knowledgeSearch?.title        || e.knowledgeArticle?.title        || ''
          })).sort((a,b) => a.timestampMs - b.timestampMs);

          const customer = conv.participants.find(p => p.purpose === 'customer');
          const sessions = customer?.sessions || [];

          // Process sessions in parallel
          const sessionResults = await Promise.all(sessions.map(async ses => {
            if (!ses.recording) return [];
            try {
              const urlReq = await fetch(
                `https://api.${region}.pure.cloud/api/v2/speechandtextanalytics/conversations/${cid}/communications/${ses.sessionId}/transcripturl`,
                { headers: { 'Authorization': `Bearer ${token}` } }
              );
              const { url } = await urlReq.json();
              const transcript = await (await fetch(url)).json();

              const phrases = [];
              transcript.transcripts.forEach(t => t.phrases.forEach(p =>
                phrases.push({ endMs: +p.startTimeMs + (p.duration?.milliseconds || 0), text: p.text })
              ));
              phrases.sort((a,b) => a.endMs - b.endMs);

              const merged = [];
              for (let phr of phrases) {
                for (let s of sugList) {
                  const diff = s.timestampMs - phr.endMs;
                  if (diff < 2000) continue;
                  if (diff > 6000) break;
                  merged.push({ phrase: phr.text, documentId: s.documentId, title: s.title,
                    confidence: s.confidence, suggestionDelayMs: diff, conversationId: cid });
                  break;
                }
              }
              return merged;
            } catch (e) {
              log(`Skip session ${ses.sessionId}: ${e}`);
              return [];
            }
          }));

          sessionResults.flat().forEach(item => mergedBatch.push(item));
        }));

        log(`Batch ${batchNumber} done, rows: ${mergedBatch.length}`);
        downloadCSV(mergedBatch, `merged_timeline_batch_${batchNumber}.csv`);
      }
    }

    function downloadCSV(rows, fname) {
      if (!rows.length) { log('No rows to export for this batch'); return; }
      const hdrs  = Object.keys(rows[0]);
      const lines = rows.map(r => hdrs.map(h => `"${(r[h]||'').toString().replace(/"/g,'""')}"`).join(','));
      const csv   = [hdrs.join(','), ...lines].join('\n');
      const blob  = new Blob([csv], { type: 'text/csv' });
      const url   = URL.createObjectURL(blob);
      const a     = document.createElement('a'); a.href = url; a.download = fname;
      document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
    }

    document.getElementById('btnTranscripts').addEventListener('click', async () => {
      logEl.textContent = '';
      log('Running export in batches...');
      await mainTranscripts();
    });
  </script>
</body>
</html>
