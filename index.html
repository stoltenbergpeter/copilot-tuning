<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>KB & Transcript SPA (Implicit Grant)</title>
  <!-- Load Spark components and styling -->
  <script type="module" src="https://app.usw2.pure.cloud/spark-components/build-assets/4.88.0-373/genesys-webcomponents/genesys-webcomponents.esm.js"></script>
  <link href="https://app.usw2.pure.cloud/spark-components/build-assets/4.88.0-373/genesys-webcomponents/genesys-webcomponents.css" rel="stylesheet" />
  <style>
    section { padding: 16px; margin: auto; max-width: 600px; }
    pre { background: #f4f4f4; padding: 16px; border-radius: 4px; max-height: 300px; overflow: auto; white-space: pre-wrap; }
  </style>
</head>
<body>
  <!-- Auth section -->
  <section id="authSection" hidden>
    <gux-page-header>
      <h1 slot="heading" align="center">Authenticate</h1>
    </gux-page-header>
    <gux-form-field-text-like>
      <label slot="label">Client ID</label>
      <input type="text" slot="input" id="inputClientId" placeholder="Enter your Client ID" />
    </gux-form-field-text-like>
    <gux-form-field-text-like>
      <label slot="label">Region</label>
      <input type="text" slot="input" id="inputRegion" placeholder="e.g. usw2" />
    </gux-form-field-text-like>
    <div style="margin-top:16px; text-align:center;">
      <gux-button accent="primary" id="btnAuth">Authenticate</gux-button>
    </div>
  </section>

  <!-- Main app section (hidden until auth) -->
  <section id="appSection" hidden>
    <gux-page-header>
      <h1 slot="heading" align="center">Suggestions Manager</h1>
    </gux-page-header>

    <!-- Form fields -->
    <gux-form-field-text-like>
      <label slot="label">Agent IDs (JSON array)</label>
      <input type="text" slot="input" id="inputAgentIds" placeholder='["id1","id2"]' />
    </gux-form-field-text-like>
    <gux-form-field-text-like>
      <label slot="label">Interval (start/end ISO)</label>
      <input type="text" slot="input" id="inputInterval" placeholder="2025-01-01T00:00:00/2025-01-02T00:00:00" />
    </gux-form-field-text-like>
    <gux-form-field-text-like>
      <label slot="label">Queue IDs (JSON array)</label>
      <input type="text" slot="input" id="inputQueueIds" placeholder='["queue1","queue2"]' />
    </gux-form-field-text-like>
    <gux-form-field-text-like>
      <label slot="label">Batch Size</label>
      <input type="number" slot="input" id="inputBatchSize" placeholder="10" />
    </gux-form-field-text-like>

    <!-- Action buttons -->
    <div style="display: flex; gap: 8px; margin-top: 16px;">
      <gux-button accent="primary" id="btnTranscripts">Run Transcripts & Download CSV</gux-button>
      <gux-button accent="secondary" id="btnLogout">Logout</gux-button>
    </div>

    <!-- Log output -->
    <pre id="log"></pre>
  </section>

  <script>
    // helper to log both console and on-page
    const logEl = document.getElementById('log');
    function log(msg) {
      console.log(msg);
      logEl.textContent += msg + '\n';
    }

    window.addEventListener('load', () => {
      // 1) parse URL params & sync to sessionStorage
      const url = new URL(window.location.href);
      let gc_region          = url.searchParams.get('gc_region');
      let gc_clientId        = url.searchParams.get('gc_clientId');
      let gc_redirectUrl     = url.searchParams.get('gc_redirectUrl');
      let gc_conversationId  = url.searchParams.get('gc_conversationId');

      if (gc_region) {
        sessionStorage.setItem('gc_region', gc_region);
      } else {
        gc_region = sessionStorage.getItem('gc_region');
      }
      if (gc_clientId) {
        sessionStorage.setItem('gc_clientId', gc_clientId);
      } else {
        gc_clientId = sessionStorage.getItem('gc_clientId');
      }
      if (gc_redirectUrl) {
        sessionStorage.setItem('gc_redirectUrl', gc_redirectUrl);
      } else {
        gc_redirectUrl = sessionStorage.getItem('gc_redirectUrl');
      }
      if (gc_conversationId) {
        sessionStorage.setItem('gc_conversationId', gc_conversationId);
      } else {
        gc_conversationId = sessionStorage.getItem('gc_conversationId');
      }

      //log(`Params → region:${gc_region}, clientId:${gc_clientId}, redirectUrl:${gc_redirectUrl}`);

      // 2) check for token in hash & localStorage
      const hash = window.location.hash.substring(1);
      const params = new URLSearchParams(hash);
      const tokenFromHash = params.get('access_token');
      if (tokenFromHash) {
        //log('Received token in URL hash, saving to localStorage');
        localStorage.setItem('accessToken', tokenFromHash);
        history.replaceState(null, '', window.location.pathname);
      }
      const token = localStorage.getItem('accessToken');

      // 3) decide whether to auto‐redirect, show auth form, or show app
      if (token) {
        //log('Token found – showing app');
        document.getElementById('authSection').hidden = true;
        document.getElementById('appSection').hidden = false;
        registerSparkComponents();
      }
      else if (gc_region && gc_clientId && gc_redirectUrl) {
        log('No token yet, auto‐redirecting to OAuth');
        const authUrl = `https://login.${gc_region}.pure.cloud/oauth/authorize` +
                        `?response_type=token&client_id=${gc_clientId}` +
                        `&redirect_uri=${encodeURIComponent(gc_redirectUrl)}`;
        window.location.href = authUrl;
      }
      else {
        //log('Missing OAuth params – showing auth form');
        document.getElementById('authSection').hidden = false;
        document.getElementById('appSection').hidden = true;
      }
    });

    // manual auth button
    document.getElementById('btnAuth').addEventListener('click', () => {
      const clientId = document.getElementById('inputClientId').value.trim();
      const region   = document.getElementById('inputRegion').value.trim();
      if (!clientId || !region) return alert('Both Client ID and Region are required.');
      const redirectUri = window.location.origin + window.location.pathname;
      sessionStorage.setItem('gc_clientId', clientId);
      sessionStorage.setItem('gc_region', region);
      sessionStorage.setItem('gc_redirectUrl', redirectUri);
      //log(`Redirecting to OAuth: region=${region}, clientId=${clientId}`);
      const authUrl = `https://login.${region}.pure.cloud/oauth/authorize` +
                      `?response_type=token&client_id=${clientId}` +
                      `&redirect_uri=${encodeURIComponent(redirectUri)}`;
      window.location.href = authUrl;
    });

    // logout
   document.getElementById('btnLogout').addEventListener('click', () => {
    log('Logging out…');
    // Remove OAuth token
    localStorage.removeItem('accessToken');
    // Remove any stored Genesys Cloud params
    sessionStorage.removeItem('gc_region');
    sessionStorage.removeItem('gc_clientId');
    sessionStorage.removeItem('gc_redirectUrl');
    sessionStorage.removeItem('gc_conversationId');
    // Refresh to return to auth form
    window.location.reload();
  });

    // main export logic
    async function mainTranscripts() {
      const token    = localStorage.getItem('accessToken');
      const region   = sessionStorage.getItem('gc_region');
      const agentIds = JSON.parse(document.getElementById('inputAgentIds').value);
      const queueIds = JSON.parse(document.getElementById('inputQueueIds').value);
      const interval = document.getElementById('inputInterval').value;
      const batchSize = parseInt(document.getElementById('inputBatchSize').value, 10) || Infinity;
      const [start, end] = interval.split('/');

      log('Fetching conversations...');
      const convResp = await fetch(
        `https://api.${region}.pure.cloud/api/v2/analytics/conversations/details/query`, {
          method: 'POST',
          headers: { 'Authorization': `Bearer ${token}`, 'Content-Type': 'application/json' },
          body: JSON.stringify({
            interval: `${start}/${end}`,
            order: 'desc',
            orderBy: 'conversationStart',
            paging: { pageSize: 100 },
            segmentFilters: [
              { type:'or', predicates: agentIds.map(id=>({type:'dimension',dimension:'userId',value:id})) },
              { type:'or', predicates: queueIds.map(id=>({type:'dimension',dimension:'queueId',value:id})) }
            ]
          })
        }
      );
      const { conversations = [] } = await convResp.json();
      log(`Conversations fetched: ${conversations.length}`);

      let batchNumber = 0;
      for (let i = 0; i < conversations.length; i += batchSize) {
        batchNumber++;
        const batch = conversations.slice(i, i + batchSize);
        log(`Processing batch ${batchNumber} (${batch.length} convs)...`);

        // fetch suggestions in parallel
        const sugData = await Promise.all(batch.map(conv =>
          fetch(`https://api.${region}.pure.cloud/api/v2/conversations/${conv.conversationId}/suggestions`, {
            headers: { 'Authorization': `Bearer ${token}` }
          })
            .then(r => r.json())
            .then(j => ({ id: conv.conversationId, entities: j.entities || [] }))
        ));

        const mergedBatch = [];
        await Promise.all(batch.map(async conv => {
          const sugEntry = sugData.find(s=>s.id===conv.conversationId);
          const sugList = sugEntry.entities
            .map(e=>({
              timestampMs: new Date(e.dateCreated).getTime(),
              documentId: e.knowledgeSearch?.document?.id || e.knowledgeArticle?.document?.id||'',
              confidence: e.knowledgeSearch?.confidence||e.knowledgeArticle?.confidence||'',
              title: e.knowledgeSearch?.title||e.knowledgeArticle?.title||''
            }))
            .sort((a,b)=>a.timestampMs-b.timestampMs);

          const customer = conv.participants.find(p=>p.purpose==='customer');
          const sessions = customer?.sessions||[];

          await Promise.all(sessions.map(async ses => {
            if (!ses.recording) {
              log(`Skip session ${ses.sessionId}: recording disabled`);
              return;
            }
            try {
              const urlReq = await fetch(
                `https://api.${region}.pure.cloud/api/v2/speechandtextanalytics/conversations/${conv.conversationId}/communications/${ses.sessionId}/transcripturl`,
                { headers:{ 'Authorization':`Bearer ${token}` } }
              );
              const { url } = await urlReq.json();
              const transcript = await (await fetch(url)).json();

              const phrases = [];
              transcript.transcripts.forEach(t => t.phrases.forEach(p =>
                phrases.push({ endMs: +p.startTimeMs + (p.duration?.milliseconds||0), text: p.text })
              ));
              phrases.sort((a,b)=>a.endMs-b.endMs);

              for (let phr of phrases) {
                for (let s of sugList) {
                  const diff = s.timestampMs - phr.endMs;
                  if (diff < 2000) continue;
                  if (diff > 6000) break;
                  mergedBatch.push({
                    phrase: phr.text,
                    documentId: s.documentId,
                    title: s.title,
                    confidence: s.confidence,
                    suggestionDelayMs: diff,
                    conversationId: conv.conversationId
                  });
                  break;
                }
              }
            } catch (e) {
              log(`Skip session ${ses.sessionId}: ${e}`);
            }
          }));
        }));

        log(`Batch ${batchNumber} done, rows: ${mergedBatch.length}`);
        downloadCSV(mergedBatch, `merged_timeline_batch_${batchNumber}.csv`);
      }
    }

    function downloadCSV(rows, fname) {
      if (!rows.length) { log('No rows to export for this batch'); return; }
      const hdrs = Object.keys(rows[0]);
      const lines = rows.map(r => hdrs.map(h => `"${(r[h]||'').toString().replace(/"/g,'""')}"`).join(','));
      const csv = [hdrs.join(','), ...lines].join('\n');
      const blob = new Blob([csv],{type:'text/csv'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = fname;
      document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
    }

    document.getElementById('btnTranscripts').addEventListener('click', async () => {
      logEl.textContent = '';
      log('Starting export in batches…');
      await mainTranscripts();
    });
  </script>
</body>
</html>
